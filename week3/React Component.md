# 학습 키워드

- REST API 와 GraphQL
    - REST API 란 무엇인가
    - GraphQL은 왜 등장했는가?
    - REST API vs GraphQL
- JSON
- DSL(Domain-Specific Language)
- 선언형 프로그래밍
- 명령형 프로그래밍
- SRP(단일 책임 원칙)
- Atomic Design
- React component 와 props

## ✔️ 키워드 정리

### REST API 와 GraphQL

#### REST API 란 무엇인가

두 컴퓨터 시스템이 인터넷을 통해 정보를 안전하게 교환하기 위햐 사용하는 인터페이스이다.

REST API를 사용하면 이런 이점들이 있다.
- 확장성: 클라이언트-서버 상호작용을 최적화하기 때문에 효율적으로 크기를 조정할 수 있다.
- 유연성: 클라이언트-서버 분리를 지원하기 때문에 각 부분이 독립적으로 발전할 수 있도록 다양한 서버 구성 요소를 단순화하고 분리한다. 서버 애플리케이션의 플랫폼이나 기술 변경은 클라이언트 애플리케이션에 영향을 주지 않는다. 애플리케이션 함수를 계층화하는 기능은 유연성을 더욱 향상시킨다.
- 독립성: API 설계에 영향을 주지 않고 다양한 프로그래밍 언어로 클라이언트 및 서버 애플리케이션을 모두 작성할 수 있다.

REST API 디자인 원칙은 다음과 같다.
1. 균일한 인터페이스: 요청이 어디에서 오는지와 무관하게, 동일한 리소스에 대한 모든 API 요청은 동일하게 보여야한다.
2. 클라이언트-서버 디커플링: REST API 디자인에서 클라이언트와 서브 애플리케이션은 서로간 완전히 독립적이어야한다. 서버 애플리케이션은 HTTP를 통해 요청된 데이터를 전달하는것 이외에는 클라이언트 애플리케이션을 수정하지 않아야한다.
3. Stateless: 각 요청에서 처리에 필요한 모든 정보를 포함해야한다.
4. 캐싱 가능성: 가능하면 리소스를 클라이언트나 서버측에서 캐싱할 수 있어야한다. 서버 응답에는 전달된 리소스에 대해 캐싱이 허용되는지에 대한 여부도 포함되어야한다.
5. 계층 구조 아키텍처: REST API에서는 호출과 응답이 서로 다른 계층을 통과한다.
6. 코드 온디맨드(옵션): 일반적으로 정적 리소스를 전송하지만 특정한 경우에는 응답에 실행코드를 포함할 수도 있다. 이럴 경우에, 코드는 요청시에만 실행되어야 한다.

반면에, REST API는 이러한 문제점을 갖고 있다.
- 공식화된 API 디자인 가이드가 존재하지 않음
- HTTP 프로토콜에 의존
- URI 설계가 복잡할 수 있음
- 필요 이상의 많은 데이터들을 가져옴

#### GraphQL은 왜 등장했는가?
API를 위한 쿼리 언어이다.
즉, 쿼리문을 작성하여 클라이언트에서 사용하고자 하는 데이터들을 받아와서 사용할 수 있다.

#### REST API vs GraphQL

REST API는 CRUD메서드를 사용해서 데이터를 요청하는 반면에 GraphQL은 쿼리문을 작성해서 요청한다.

- overfetching:
REST API는 resource를 기반으로 하기 때문에, 일부 속성만 필요해도 데이터 전체를 모두 불러온다. product가 커지면 방대한 데이터량으로 인한 성능 저하가 우려된다는 단점이 있다. GraphQL에서는 필요한 필드의 데이터를 쿼리로 작성해서 요청하기 때문에 이런 문제를 극복할 수 있다.

- underfetching:
REST API에서는 특정 데이터를 위해 여러 개의 엔드포인트를 사용해서 데이터를 요청해야하는 상황이 발생하기도 한다. 네트워크 오버헤드가 발생하면 요청한 데이터보다 훨씬 적은 데이터를 받을 수 있다. GraphQL에서는 필요한 데이터 구조에 맞춰 요청할 수 있기 떄문에 하나의 쿼리로 여러 데이터들을 한 번에 가져올 수 있다.

- API  버전 관리 문제:
REST API에서 새로운 기능을 추가하거나, 변경할 때 새로운 엔드 포인트를 만들어야 한다. 그러다보면 API 유지보수가 복잡해지고, 클라이언트와 서버간의 버전관리 또한 어려워진다. graphQL은 스키마 기반으로 작동하기 때문에 새로운 필드를 추가하거나, 변경할 때 기존 쿼리에 영향을 주지 않고 스키마를 확장할 수 있다는 특징이 있다.

- 서버-클라이언트 의존성 문제:
REST API에서 클라이언트는 서버의 엔드포인트 구조에 맞춰 데이터를 요청하고 파싱해야하는데, 서버에서의 변경이 일어나면 클라이언트에서 코드를 수정해야하는 일이 생긴다. GraphQL에서는 클라이언트에서 필요한 데이터 구조로 쿼리를 작성하여 요청하고 그에 맞는 데이터를 반환하는 구조이므로, 서버와 클라이언트의 의존성이 낮춰진다고 볼 수 있다.

### JSON

key와 value로 이루어져있다.

JSON.parse() 또는 JSON.stringify() 메서드를 사용한다.

JSON.parse() 메서드는 JSON 문자열의 구문을 분석하고,  Javascript값이나 객체를 생성한다.

```JSON
const json = '{"result":true, "count":42}';
const obj = JSON.parse(json);
```

이렇게 사용한다.

JSON.stringify() 메서드는 Javascript 값이나 객체를 문자열로 변환한다.

```JSON
console.log(JSON.stringify({ x: 5, y: 6 }));
// Expected output: '{"x":5,"y":6}'
```

이렇게 사용한다.

JSON 데이터는 ,를 사용하여 여러 JSON 데이터를 포함할 수 있다.

### DSL(Domain-Specific Language)

DSL은 도메인 특화 언어라고 하는데, 관련 특정 분야에 최적화된 프로그래밍 언어라고 한다. DSL은 해당 분야 또는 도메인의 개념과 규칙을 사용한다.

DSL을 사용하면 언어와 변환 엔진을 갖추어 지루한 작업을 일일히 수행할 필요가 없기 때문에 훨씬 효율적으로 작업할 수 있다는 장점이 있다.
DSL은 프로그래머와 해당 분야의 전문가를 매우 원활하게 연결해준다.
DSL 및 실행 엔진을 사용하면 대상 플랫폼에서 자유로운 DSL 코드로 애플리케이션 로직을 표현할 수 있다.

### 선언형 프로그래밍

선언형 프로그래밍은 원하는 결과를 묘사하는 방식으로 코드를 작성하는 프로그래밍 패러다임이다.

```Javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evenNumbers = numbers.filter(num => num%2 === 0);

console.log(evenNumbers);
// [2, 4, 6, 8, 10]
```

이 코드에서는 짝수를 필터링한 결과값을 evenNumbers라는 변수에 저장한다.

이러한 스타일로 코드를 작성하면 전체적인 가독성과 추상화 수준을 높일 수 있고, 개발자가 문제의 본질에 집중할 수 있도록 도움을 준다.
더불어 재사용성이 높고 병렬 처리가 유리하다는 특징을 가진다.

### 명령형 프로그래밍

명령형 프로그래밍은 코드가 어떻게 동작해야하는지에 대해 작성한다.

```Javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evenNumbers = [];

for(let i = 0; i < numbers.length; i++) {
    const num = numbers[i];
    if (num % 2 === 0) {
        evenNumbers.push(num);
    }
}

console.log(evenNumbers)
// [2, 4, 6, 8, 10]
```

명령형 프로그래밍에서는 상태와 제어 흐름을 명시적으로 관리하는 방식으로 코드를 작성한다. 따라서 코드의 가독성이 저하되거나, 재사용성이 낮아질 수 있어서 코드 관리에 있어서 많은 노력이 필요하다.

### SRP(단일 책임 원칙)

단일 책임 원칙(SRP: Single Responsibility Principle)은 다섯 가지 SOLID 애자일 원칙 중 하나이다.

클래스를 변경하는 이유가 한가지이기 위해서는 하나의 행동에 대한 책임만 갖고 있어야한다.
그리고 그 책임을 완전히 캡슐화 해야한다.

SRP를 따를 때의 이점은 다음과 같다.
- 쉬운 테스트: 책임이 하나인 클래스는 테스트 케이스가 줄어들기 때문에 테스트가 쉬워진다.
- 낮은 결합: 단일 클래스의 기능이 적어져서 종속성이 줄어든다.
- 쉬운 검색: 작고 조직이 잘 된 클래스는 검색하기 쉽다.
- 구현하기 쉬움: 단일 책임을 갖고 있기 때문에 구현 & 이해가 쉽다.

하지만 SRP에 대한 과한 고려는 이해하기 힘든 설계로 이어질 수 있으니 적당하게 잘 사용해야한다.

### Atomic Design

가장 작은 단위의 컴포넌트다.
다양한 state, 색상, 폰트, 애니메이션과 같은 추상적인 요소가 포함될 수 있다.
대표적으로 버튼, 텍스트, 아이콘 등이 있다.

Atomic Design 패턴을 사용하면 컴포넌트 재사용성이 극대화되지만,
의존성과 복잡도에 대한 영향을 미치기 때문에 프로젝트 성격에 맞게 변형을 잘 시켜서 사용해야할 것 같다.

### React component 와 props

컴포넌트를 통해 UI를 재사용 가능한 개별적인 여러 조각으로 나누어 사용할 수 있다.

```Javascript
function App(props){
    return <h1>Hello {props.name}</h1>
}

<App name="world!"/>
```

이런식으로 함수를 작성하여 컴포넌트를 생성할 수 있다.

`App` 컴포넌트에서 name을 props로 받아 사용하는데, prop는 읽기 전용이라서 수정할 수 없다.
`props`는 상위 컴포넌트에서 하위 컴포넌트로 데이터를 전달해주는 객체이다.

모든 React 컴포넌트는 props를 다룰 때 순수 함수처럼 동작해야 한다.

### 참고

<https://aws.amazon.com/ko/what-is/restful-api/><br/>
<https://s0ojin.tistory.com/70><br/>
<https://www.jetbrains.com/ko-kr/mps/concepts/domain-specific-languages/><br/>
<https://yozm.wishket.com/magazine/detail/2083/><br/>
<https://milooy.github.io/dev/220810-abstraction-and-declarative-programming/><br/>
<https://ghost4551.tistory.com/255><br/>
<https://ko.legacy.reactjs.org/docs/components-and-props.html>